import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:stream_transform/stream_transform.dart';

import 'package:nitwixt/models/models.dart' as models;
import 'package:nitwixt/src/utils/streams.dart' as streams;

import 'collections.dart' as collections;


mixin DatabaseUserMixin {

  /// Users collection
  static final CollectionReference userCollection = collections.userCollection;

  /// User from document snapshot
  static models.User userFromDocumentSnapshot(DocumentSnapshot snapshot) {
    return models.User.fromFirebaseObject(snapshot.id, snapshot.data());
  }

  /// List of users from document snapshot
  static List<models.User> userFromQuerySnapshot(QuerySnapshot querySnapshot) {
    return querySnapshot.docs.map(userFromDocumentSnapshot).toList();
  }

  static Future<Stream<List<models.User>>> getUserList({String chatid}) async {
    final Query queryUserChats = collections.userPrivateCollection.where('id', isEqualTo: 'chats').where('chats', arrayContains: chatid);
    // TODO(Valentin): Replace get by snapshot
    final QuerySnapshot querySnapshotUserChats = await queryUserChats.get();
    final List<Stream<models.User>> listStream =  querySnapshotUserChats.docs.map((QueryDocumentSnapshot queryDocumentSnapshot) {
      return queryDocumentSnapshot.reference.parent.parent.snapshots().map<models.User>(userFromDocumentSnapshot);
    }).toList();
    return Future<Stream<List<models.User>>>.value(streams.combineListOfStreams<models.User>(listStream));
  }

  static Future<Stream<Map<String, models.User>>> getUserMap({String chatid}) async {
      final Stream<List<models.User>> streamUserList = await getUserList(chatid: chatid);
      return streamUserList.map<Map<String, models.User>>((List<models.User> userList) {
        return userList.asMap().map<String, models.User>((int index, models.User user) {
          return MapEntry<String, models.User>(user.id, user);
        });
      });
  }

//  static Stream<List<models.User>> getUserList({String chatid}) {
//    final Query query = collections.userCollection.where(models.UserKeys.chats, arrayContains: chatid);
//    return query.snapshots().map(userFromQuerySnapshot);
//  }
//
//  static Stream<Map<String, models.User>> getUserMap({String chatid}) {
//    final Query query = collections.userCollection.where(models.UserKeys.chats, arrayContains: chatid);
//    return query.snapshots().map((QuerySnapshot querySnapshot) {
//      return userFromQuerySnapshot(querySnapshot).asMap().map<String, models.User>((int index, models.User user) {
//        return MapEntry<String, models.User>(user.id, user);
//      });
//    });
//  }

  static Future<void> createEmptyUser({String id}) async {
    /// id is used when I when to create a user with a fixed id (from the FirebaseUser id)
    /// If id is not provided, an automatic id will be generated by Firebase
    final models.User user = models.User();
    if (id == null || id.isEmpty) {
      // Create a new user and send back the id
      final DocumentReference documentReference = await collections.userCollection.add(user.toFirebaseObject());
      await collections.userCollection.doc(documentReference.id).update(<String, dynamic>{
        models.UserKeys.id: documentReference.id,
      });
      return documentReference.id;
    } else {
      // The id is provided, then I have to create the user and document with the specified id
      user.id = id;
      return await collections.userCollection.doc(id).set(user.toFirebaseObject());
    }
  }

  static Future createUser({String id, models.User user}) async {
    /// id is used when I when to create a user with a fixed id (from the FirebaseUser id)
    /// If user if not provided, an empty one is created
    /// If id is not provided, an automatic id will be generated by Firebase
    if (user == null) {
      return createEmptyUser(id: id);
    } else {
      String id_; // The final id
      if (id == null || id.isEmpty) {
        id_ = user.id;
      } else {
        id_ = id;
      }
      if (id_ == null || id_.isEmpty) {
        // There is no id provided as an argument or in the user
        final DocumentReference documentReference = await collections.userCollection.add(user.toFirebaseObject());
        await collections.userCollection.doc(documentReference.id).update(<String, dynamic>{
          'id': documentReference.id,
        });
        return documentReference.id;
      } else {
        // I have an id to consider
        user.id = id_;
        return await collections.userCollection.doc(id_).set(user.toFirebaseObject());
      }
    }
  }

  static Future<bool> userIdExists({String id}) async {
    final DocumentSnapshot documents = await collections.userCollection.document(id).get();
    return documents.exists;
  }

  static Future<List<models.User>> usersFromField(List<String> fieldValuesList, {String fieldName = 'username'}) async {
    if (fieldValuesList.isEmpty) {
      return Future.error('No username provided');
    }
    // Get the
    final List<QuerySnapshot> documentsList = await Future.wait(fieldValuesList.map((String username) async {
      return await collections.userCollection.where(fieldName, isEqualTo: username).get();
    }));
    final List<String> unknownUsers = <String>[];
    documentsList.asMap().forEach((int index, QuerySnapshot documents) {
      if (documents.docs.isEmpty) {
        unknownUsers.add(fieldValuesList[index]);
      }
    });
    if (unknownUsers.isNotEmpty) {
      // Some users have not been found
      if (unknownUsers.length == 1) {
        return Future.error('User "${unknownUsers[0]}" doesn\'t exist');
      } else {
        return Future.error('Users "${unknownUsers.join('", "')}" don\'t exist');
      }
    }
    // All the users have been found
    final List<models.User> allUserList = documentsList.map<models.User>((QuerySnapshot documents) {
      return userFromDocumentSnapshot(documents.docs[0]);
    }).toList();

    return allUserList;
  }

}